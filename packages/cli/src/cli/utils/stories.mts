import swc from "@swc/core";
import fsExtra from "fs-extra";
import { globby } from "globby";
import handlebars from "handlebars";
import crypto from "node:crypto";
import path from "node:path";

import { getShowcaseConfig, showcaseLog } from "./utils.mjs";

interface StoryPathsObject {
  [storyId: string]: {
    path: string;
    esmPath: string;
  };
}

interface SnapshotObject {
  meta: any;
  components: {
    [name: string]: {
      path: string;
      integrity: string;
      stories: string[];
    };
  };
}

export const getStoryComponentPaths = async (): Promise<StoryPathsObject> => {
  const config = await getShowcaseConfig();
  const paths = await globby(
    config?.stories || ["src/**/*.stories.{js,jsx,ts,tsx}"],
  );
  let pathsObject: StoryPathsObject = {};
  paths.forEach((path) => {
    const id = path.split("/").slice(-1)[0].split(".")[0];
    if (pathsObject[id]) {
      throw new Error(`Duplicate story file name found: ${path}`);
    }
    // esm path is the regular path but with .js extension
    pathsObject[id] = {
      path,
      esmPath: path.replace(/\.[^/.]+$/, ".jsx"),
    };
  });
  return pathsObject;
};

export const createMetaFile = async (): Promise<SnapshotObject> => {
  const storyPaths = await getStoryComponentPaths();
  let data: SnapshotObject = {
    meta: {
      timestamp: new Date().toISOString(),
    },
    components: {},
  };

  // transpile each story file to javascript, so we can parse it
  for (const id of Object.keys(storyPaths)) {
    const story = storyPaths[id];
    const storyFile = fsExtra.readFileSync(
      path.join(process.cwd(), story.path),
      {
        encoding: "utf-8",
      },
    );

    const output = swc.parseSync(storyFile, {
      syntax: "typescript",
      comments: false,
      script: true,
      tsx: true,
    });

    // parse all export declarations and find the story names
    const storyNames = output.body
      .filter((node) => node.type === "ExportDeclaration")
      .map((node) => {
        // @ts-ignore
        const storyName = node.declaration.declarations[0].id.value;
        return storyName;
      });

    const hash = crypto.createHash("sha256");
    hash.update(storyFile);

    data.components[id] = {
      path: story.path,
      integrity: `sha256-${hash.copy().digest("base64")}`,
      stories: storyNames,
    };
  }

  fsExtra.outputFileSync(
    path.join(process.cwd(), ".showcase/meta.json"),
    JSON.stringify(data, undefined, 2),
  );

  showcaseLog("📁 Meta file created at .showcase/meta.json");

  return data;
};

export const createCompileTarget = async (storyPaths: StoryPathsObject) => {
  const imports = Object.keys(storyPaths).map((componentName) => ({
    name: componentName,
    path: "@showcasejs/root/" + storyPaths[componentName].path,
  }));
  const componentNames = Object.keys(storyPaths).map((storyId) => storyId);
  let template = `// this virtual module was auto-generated by Showcase.js on {{ timestamp }}
{{#each imports}}
import * as {{ this.name }} from "{{ this.path }}";
{{/each}}
export const stories = { {{ componentNames }} };
`;
  const mainPaths = await globby(".showcase/main.{tsx,ts,jsx,js}");
  if (mainPaths.length > 0) {
    template += `export * as main from '@showcasejs/root/${mainPaths[0]}';\n`;
  } else {
    template += "export const main = undefined;\n";
  }
  const previewPaths = await globby(".showcase/preview.{tsx,ts,jsx,js}");
  if (previewPaths.length > 0) {
    template += `export * as preview from '@showcasejs/root/${previewPaths[0]}';\n`;
  } else {
    template += "export const preview = undefined;\n";
  }
  const compiler = handlebars.compile(template);
  const compiled = compiler({
    timestamp: new Date().toISOString(),
    imports,
    componentNames,
  });
  return compiled;
};
